name: Monitor Upstream and Run Analysis

on:
  schedule:
    - cron: "*/15 * * * *"
  workflow_dispatch:
    inputs:
      start_commit:
        description: "Start commit SHA"
        required: false
        type: string

permissions:
  actions: write
  contents: write
  issues: write
  workflows: write

jobs:
  monitor-upstream:
    runs-on: ubuntu-latest
    env:
      # NEED TO BE CONFIGURED EACH PROJECT
      UPSTREAM_REPO: "psf/requests"
      BRANCH: "main"
      DISPATCH_TIMEOUT: 1800 # 30 minutes

    steps:
      - name: Checkout the forked repo
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          path: forked-repo
          fetch-depth: 0

      - name: Sync fork with upstream
        continue-on-error: true
        run: |
          set -euo pipefail
          cd forked-repo
      
          # Make Git happy on hosted runners
          git config --global --add safe.directory "$PWD"
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
      
          # Ensure refs are current
          git fetch --prune origin
          git remote add upstream "https://github.com/${UPSTREAM_REPO}.git" || true
          git fetch --prune upstream --tags
      
          # Local branch is guaranteed to exist
          git checkout "${BRANCH}"
      
          # Optional: stash (usually no changes in CI, but harmless)
          git -c advice.skippedCherryPicks=false stash push -u -m "autostash" || true
      
          echo "Rebasing ${BRANCH} onto upstream/${BRANCH}..."
          if ! git rebase -X theirs --rebase-merges "upstream/${BRANCH}"; then
            echo "Rebase failed; aborting."
            git rebase --abort || true
            git stash pop || true
            exit 1
          fi
      
          # Restore any stashed changes (likely none)
          git stash pop || true
      
          # Push only if diverged; use --force-with-lease for safety
          if ! git diff --quiet "origin/${BRANCH}..HEAD"; then
            git push --force-with-lease origin "${BRANCH}"
            echo "Pushed rebased ${BRANCH} to origin."
          else
            echo "No changes to push after rebase."
          fi

          # Change back to the root directory
          cd ..

      - name: Clean up the workspace
        run: |
          rm -rf "$GITHUB_WORKSPACE/forked-repo"

      - name: Prepare and restore cache folder
        id: cache-folder
        uses: actions/cache/restore@v4
        with:
          path: .continuous-analysis-cache
          key: continuous-analysis-cache-${{ github.repository }}-

      - name: Create cache folder if not exists
        run: |
          mkdir -p .continuous-analysis-cache

      - name: Load last seen SHA from cache folder
        id: last-sha
        run: |
          # If start_commit is provided, set it as the last seen SHA
          if [[ -n "${{ inputs.start_commit }}" ]]; then
            echo "last_sha=${{ inputs.start_commit }}" >> $GITHUB_OUTPUT
            echo "Start commit provided: ${{ inputs.start_commit }}"
            exit 0
          fi

          # Declare the file path to the last seen SHA
          FILE=".continuous-analysis-cache/last_sha.txt"

          # Check if the file exists and load the last seen SHA
          if [[ -f "$FILE" ]]; then
            LAST_SHA=$(cat "$FILE")
            echo "Last seen SHA found in cache: $LAST_SHA"
          else
            LAST_SHA=""
            echo "No last seen SHA found in cache"
          fi

          # Output the last seen SHA to the GitHub Actions output for further use
          echo "last_sha=$LAST_SHA" >> $GITHUB_OUTPUT

      - name: Get upstream commits and find new ones
        id: check-commits
        run: |
          # Print the upstream repo and branch to the console
          echo "Finding the latest 50 commits from the upstream repo: $UPSTREAM_REPO@$BRANCH"

          # Get the latest 50 commits from the upstream repo and save them to a JSON file
          curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${UPSTREAM_REPO}/commits?sha=${BRANCH}&per_page=50" \
              > commits.json

          # Parse the first commit SHA from the JSON file for sanity check
          if ! jq -e '.[0].sha' commits.json > /dev/null; then
            echo "Failed to parse SHA from commits.json"
            exit 1
          fi

          # Parse all commit SHAs (from newest to oldest) from the JSON file and save to all_commits.txt
          jq -r '.[].sha' commits.json > all_commits.txt

          # Get the last seen SHA from the previous step
          LAST_SEEN="${{ steps.last-sha.outputs.last_sha }}"
          echo "Last seen SHA: $LAST_SEEN"

          # If the last seen SHA is empty, select the latest commit SHA
          if [[ -z "$LAST_SEEN" ]]; then
            head -n 1 all_commits.txt > new_commits.txt
            echo "has_new_commits=true" >> $GITHUB_OUTPUT
            echo "First-time run â€” selecting the latest commit: $(head -n 1 all_commits.txt)"
          else
            # If the last seen SHA is not empty, filter out previously seen commits
            # Print all new commit SHAs (above the last seen SHA) to new_commits.txt
            awk -v sha="$LAST_SEEN" '$0 ~ sha {exit} {print}' all_commits.txt > new_commits.txt

            if [ ! -s new_commits.txt ]; then
              echo "No new commits to process."
              echo "has_new_commits=false" >> $GITHUB_OUTPUT
            else
              echo "New commits to process:"
              echo "has_new_commits=true" >> $GITHUB_OUTPUT
              cat new_commits.txt
            fi
          fi

      - name: Trigger analysis workflows for new commits sequentially
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Read the commits from file
          mapfile -t commits < new_commits.txt

          # If no new commits to process, exit
          if [ ${#commits[@]} -eq 0 ]; then
            echo "No new commits to process"
            exit 0
          fi

          # If start_commit is provided, generate a random dispatch ID for history analysis
          if [[ -n "${{ inputs.start_commit }}" ]]; then
            dispatch_id="$(date -u +%Y%m%dT%H%M%SZ)-$RANDOM"
          fi

          # Extract repository name for future usages
          repo_name=$(echo "${GITHUB_REPOSITORY}" | cut -d'/' -f2)

          # Trigger analysis workflows for new commits sequentially
          for commit in $(tac new_commits.txt); do
            echo "Dispatching workflow for commit: $commit"

            # Generate a target artifact name to look to detect if the workflow has completed
            if [[ -n "${{ inputs.start_commit }}" ]]; then
              artifact_name="continuous-analysis-history-results-${dispatch_id}-${repo_name}-${commit}"
            else
              artifact_name="continuous-analysis-results-${repo_name}-${commit}"
            fi

            # Trigger the analysis workflow
            gh workflow run run-analysis.yml \
              --repo "${GITHUB_REPOSITORY}" \
              --ref "${{ env.BRANCH }}" \
              --field commit="$commit" \
              --field dispatch_id="$dispatch_id"

            # Create a variable to indicate if the artifact is created
            echo "Waiting for artifact ${artifact_name} to be created..."
            artifact_created=false

            # Set the end time for the timeout
            end_time=$(( $(date +%s) + DISPATCH_TIMEOUT ))
            
            # Continue to check and wait for the target artifact to be created until the end time is reached
            while [ "$(date +%s)" -lt "$end_time" ]; do
              if curl -s -H "Authorization: token $GH_TOKEN" \
                "https://api.github.com/repos/${GITHUB_REPOSITORY}/actions/artifacts?per_page=100" \
                | jq -r '.artifacts[].name' 2>/dev/null | grep -q "^${artifact_name}"; then
                artifact_created=true
                echo "Artifact ${artifact_name} found."
                break
              fi
              echo "Artifact not found yet, waiting 30 seconds..."
              sleep 30 # 30 seconds between checks
            done

            # Check if the workflow is timed out before dispatching the next workflow
            if [ "$artifact_created" = false ]; then
              echo "ERROR: Timed out waiting for artifact ${artifact_name} for ${commit}" >&2
              exit 1
            fi
          done

      - name: Update SHA cache
        if: steps.check-commits.outputs.has_new_commits == 'true'
        run: |
          NEWEST=$(head -n 1 new_commits.txt)
          echo "$NEWEST" > .continuous-analysis-cache/last_sha.txt

      - name: Generate timestamp
        if: steps.check-commits.outputs.has_new_commits == 'true'
        id: timestamp
        run: |
          ts=$(date +'%Y%m%d-%H%M')
          echo "ts=$ts" >> "$GITHUB_OUTPUT"
          echo "Generated timestamp: $ts"

      - name: Save updated SHA cache with timestamp
        if: steps.check-commits.outputs.has_new_commits == 'true'
        uses: actions/cache/save@v4
        with:
          path: .continuous-analysis-cache
          key: continuous-analysis-cache-${{ github.repository }}-${{ steps.timestamp.outputs.ts }}
